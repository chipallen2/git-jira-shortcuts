#!/usr/bin/env node

const path = require('path');
const fs = require('fs');
const readline = require('readline');
const os = require('os');

const SHELL_SCRIPT = path.resolve(__dirname, '..', 'shell', 'git-extras.sh');
const ENV_FILE = path.join(os.homedir(), '.git-jira-shortcuts.env');
const ZSHRC = path.join(os.homedir(), '.zshrc');
const SOURCE_MARKER = '# git-jira-shortcuts';
const PKG = require(path.resolve(__dirname, '..', 'package.json'));

// â”€â”€ helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

function ask(rl, question, defaultVal) {
  const suffix = defaultVal ? ` (${defaultVal})` : '';
  return new Promise((resolve) => {
    rl.question(`${question}${suffix}: `, (answer) => {
      resolve(answer.trim() || defaultVal || '');
    });
  });
}

function readExistingEnv() {
  if (!fs.existsSync(ENV_FILE)) return {};
  const content = fs.readFileSync(ENV_FILE, 'utf8');
  const vars = {};
  for (const line of content.split('\n')) {
    const m = line.match(/^export\s+(\w+)="(.*)"/);
    if (m) vars[m[1]] = m[2];
  }
  return vars;
}

function writeEnvFile(vars) {
  const lines = [
    '# git-jira-shortcuts configuration',
    `# Generated by git-jira-shortcuts init on ${new Date().toISOString()}`,
    '',
    `export GJS_TICKET_PREFIX="${vars.GJS_TICKET_PREFIX || ''}"`,
    `export GJS_JIRA_DOMAIN="${vars.GJS_JIRA_DOMAIN || ''}"`,
    `export GJS_JIRA_API_TOKEN="${vars.GJS_JIRA_API_TOKEN || ''}"`,
    `export GJS_BRANCH_WEBHOOK_URL="${vars.GJS_BRANCH_WEBHOOK_URL || ''}"`,
    '',
  ];
  fs.writeFileSync(ENV_FILE, lines.join('\n'), 'utf8');
}

function ensureZshrcSourceLines() {
  let content = '';
  if (fs.existsSync(ZSHRC)) {
    content = fs.readFileSync(ZSHRC, 'utf8');
  }

  if (content.includes(SOURCE_MARKER)) {
    console.log('  ~/.zshrc already has source lines â€” skipping.');
    return;
  }

  const block = [
    '',
    SOURCE_MARKER,
    '[ -f ~/.git-jira-shortcuts.env ] && source ~/.git-jira-shortcuts.env',
    'source "$(git-jira-shortcuts path)"',
    '',
  ].join('\n');

  fs.appendFileSync(ZSHRC, block, 'utf8');
  console.log('  âœ… Source lines added to ~/.zshrc');
}

// â”€â”€ commands â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

async function runInit() {
  const existing = readExistingEnv();
  const hasExisting = Object.keys(existing).length > 0;

  console.log('');
  console.log('ðŸ”§ git-jira-shortcuts init');
  console.log('â”€'.repeat(40));

  if (hasExisting) {
    console.log('  Found existing config at ~/.git-jira-shortcuts.env');
    console.log('  Press Enter to keep current values shown in parentheses.');
    console.log('');
  }

  const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout,
  });

  try {
    const ticketPrefix = await ask(
      rl,
      '  Jira project key (e.g. MYPROJ, ACME)',
      existing.GJS_TICKET_PREFIX
    );

    const jiraDomain = await ask(
      rl,
      '  Jira domain (e.g. yourco.atlassian.net)',
      existing.GJS_JIRA_DOMAIN
    );

    console.log('');
    console.log('  To generate a Jira API token:');
    console.log('    1. Go to https://id.atlassian.com/manage-profile/security/api-tokens');
    console.log('    2. Create a token');
    console.log('    3. Base64-encode it: echo -n "email:token" | base64');
    console.log('');

    const jiraToken = await ask(
      rl,
      '  Jira API token (base64)',
      existing.GJS_JIRA_API_TOKEN
    );

    const webhookUrl = await ask(
      rl,
      '  Branch name webhook URL (optional, Enter to skip)',
      existing.GJS_BRANCH_WEBHOOK_URL
    );

    console.log('');
    console.log('  Writing config...');

    writeEnvFile({
      GJS_TICKET_PREFIX: ticketPrefix,
      GJS_JIRA_DOMAIN: jiraDomain,
      GJS_JIRA_API_TOKEN: jiraToken,
      GJS_BRANCH_WEBHOOK_URL: webhookUrl,
    });
    console.log('  âœ… Config written to ~/.git-jira-shortcuts.env');

    ensureZshrcSourceLines();

    console.log('');
    console.log('  ðŸŽ‰ Setup complete! Reload your shell:');
    console.log('     source ~/.zshrc');
    console.log('');
    console.log('  Then try:');
    console.log('     ghelp        â€” list all commands');
    console.log('     testJira     â€” verify Jira connection');
    console.log('');
  } finally {
    rl.close();
  }
}

function runPath() {
  console.log(SHELL_SCRIPT);
}

function runHelp() {
  console.log(`
git-jira-shortcuts v${PKG.version}
Git + Jira workflow shortcuts for zsh

Usage:
  git-jira-shortcuts init       Interactive setup wizard
  git-jira-shortcuts path       Print path to shell script (used by source)
  git-jira-shortcuts --version  Print version
  git-jira-shortcuts --help     Show this help

After init, these zsh commands are available:
  gs        Clean git status          gw/gswitch   Switch branches
  gf/gcfast Fast commit + push        gc/gcommit   Commit + push
  gt/gstart Create branch from Jira   gm/gmerge    Safe merge
  gpu/gpush Push with tracking        gdel/gdelete Delete branch
  gl/glist  List pending files        gr/greset    Reset files
  gdiff     Diff vs target branch     grecent      Recent branches
  grepos    Show all repo branches    testJira     Test Jira API
  ghelp     Show all commands
`);
}

// â”€â”€ main â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

const command = process.argv[2];

switch (command) {
  case 'init':
    runInit().catch((err) => {
      console.error('Error during init:', err.message);
      process.exit(1);
    });
    break;
  case 'path':
    runPath();
    break;
  case '--version':
  case '-v':
    console.log(PKG.version);
    break;
  case '--help':
  case '-h':
  case undefined:
    runHelp();
    break;
  default:
    console.error(`Unknown command: ${command}`);
    runHelp();
    process.exit(1);
}
